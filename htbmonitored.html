<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Blog</title>
    <link rel="stylesheet" href="style.css">
    <script>
        // JavaScript to toggle sub-topics visibility
        function toggleSubtopics(event) {
            const subtopics = event.target.nextElementSibling; // Get the next sibling (sub-topic list)
            if (subtopics.style.display === "block") {
                subtopics.style.display = "none"; // Hide the sub-topics
            } else {
                subtopics.style.display = "block"; // Show the sub-topics
            }
        }
    </script>
</head>
<body>
    <!-- Sidebar -->
    <div class="sidebar">
        <!-- Website Name -->
        <h1>net-nomad</h1>
        
        <!-- Profile Image -->
        <img src="https://avatars.githubusercontent.com/u/198267592?v=4" alt="Profile Image"> <!-- Replace with your actual image URL -->

        <a class="about-me" href="" target="_blank">About Me</a>
        
        <!-- GitHub link -->
        <a class="github-link" href="https://github.com/net-nomad" target="_blank">My GitHub</a>
        
        <!-- Topics heading -->
        <div class="topics-heading">Topics</div>
        
        <a href="javascript:void(0);" onclick="toggleSubtopics(event)">Browser Exploitation</a>
        <div class="subtopics">
            <a href="tech/article1.html">General Browser Architecture</a>
        </div>
        
        <a href="javascript:void(0);" onclick="toggleSubtopics(event)">Python</a>
        <div class="subtopics">
            <a href="travel/article1.html">The Fundamentals of Python</a>
        </div>
        
        <a href="javascript:void(0);" onclick="toggleSubtopics(event)">C++</a>
        <div class="subtopics">
            <a href="lifestyle/article1.html">The Fundamentals of C++</a>
        </div>

        <a href="javascript:void(0);" onclick="toggleSubtopics(event)">Intel Assembly</a>
        <div class="subtopics">
            <a href="lifestyle/article1.html">The Fundamentals of Intel Assembly</a>
        </div>

        <a href="javascript:void(0);" onclick="toggleSubtopics(event)">Penetration Testing</a>
        <div class="subtopics">
            <a href="lifestyle/article1.html">?</a>
        </div>

        <a href="javascript:void(0);" onclick="toggleSubtopics(event)">ARM Assembly</a>
        <div class="subtopics">
            <a href="lifestyle/article1.html">The Fundamentals of ARM Assembly</a>
        </div>

        <a href="javascript:void(0);" onclick="toggleSubtopics(event)">JavaScript</a>
        <div class="subtopics">
            <a href="jsfun.html">The Fundamentals of JavaScript</a>
        </div>

        <a href="javascript:void(0);" onclick="toggleSubtopics(event)">C</a>
        <div class="subtopics">
            <a href="lifestyle/article1.html">The Fundamentals of C</a>
        </div>

        <a href="javascript:void(0);" onclick="toggleSubtopics(event)">Debuggers</a>
        <div class="subtopics">
            <a href="lifestyle/article1.html">?</a>
        </div>

        <a href="javascript:void(0);" onclick="toggleSubtopics(event)">Hack The Box</a>
        <div class="subtopics">
            <a href="htblame.html">Lame</a>
            <a href="htbblue.html">Blue</a>
        </div>
    </div>
    <!-- Main content -->
    <div class="main-content">
        <h1>Hack The Box: Monitored</h1>
        <h3>Feb 11 2025</h3>
        <p>Wanting a greater challenged, I've decided to take on my first medium-difficultly box in HTB. This one doesn't have many pwns, and has just turned a year old. The "About" section is as follows:</p>
        <p>"Monitored is a medium-difficulty Linux machine that features a Nagios instance. Credentials for the service are obtained via the SNMP protocol, which reveals a username and password combination provided as command-line parameters. Using the Nagios API, an authentication token for a disabled account is obtained, which leads to access to the application's dashboard. From there, a SQL injection (`[CVE-2023-40931](https://nvd.nist.gov/vuln/detail/CVE-2023-40931)`) is abused to obtain an administrator API key, with which a new admin account is created and used to run arbitrary commands on the instance, leading to a reverse shell. Finally, `sudo` access to a bash script is abused to read the `root` user's SSH key and authenticate as `root`."</p>
        <p>With that, I dive in.</p>
        <p>My first question is: what even is Nagios? I've read about it while skimming detali-sparse, generalized security articles, but I can't tell you what it is or why it's important. So, as any decent hacker should, I search for information.</p>
        <p>On its homepage: "Nagios is a powerful monitoring system that enables organizations to identify and resolve IT infrastructure problems before they affect critical business processes."</p>
        <p>Wow, that's really helpful.</p>
        <p>Scrolling down, I learn that Nagios is some kind of IT infrastructure monitoring software that ensures systems, applications, and services area functioning properly. When something goes wrong, Nagios is able to alert IT staff of the problem so that they can begin fixing whatever it is. This is important because intervening quickly can stop outages from being as impactful on customers and business processes.

Nagios has an open-source community that's contributed "thousands of plugins and add-ons", and Nagios projects can be used to build monitoring solutions.

So we have three individual Nagios projects: Nagios Core, Nagios Plugins, and Nagios Mod Gearman, each is distributed as part of the Nagios Core Services Platform (CSP) download for "ease of use" and rapid deployment. You download the Nagios CSP to get access to smart monitoring wizards, informative reports, and insightful dashboards. Interesting so far.

I'm going to take a look at Nagios Core's documentation, as it's described as a "monitoring engine" and just grabs my attention, for some reason.</p>
        <p>But wait! I don't want to get ahead of myself. I haven't even spawned the target machine yet, nor have I started my Kali VM. Let's do that, and run a reconnaissance scan afterwards to see what I can find.

I initiate the VPN connection, ping 10.129.230.96, and start formulating an Nmap scan so I can know what I'm working with. I run a basic `sudo nmap -sV -O -sC -T3 10.129.230.96` and as we can see, the host's name is nagios.monitored.htb and ports 22 (OpenSSH), 80 (HTTP), 389 (OpenLDAP), and 443 (HTTPS) are supposedly open. The web server is Apache version 2.4.56.

I also run a UDP scan, simply by appending `-sU` to the previous scan and running it again. UDP scans can take signicantly longer than other types, due to the nature of the protocol. It's connectionless, so Nmap doesn't receive an acknowledgement that the data has been received by the target unless the service on target port responds. Because of this, the state of the port cannot be immediately determined, which leads to longer wait times. 

So far, 6 minutes have gone by during this UDP scan. I hope it's worth it.

9 minutes down the drain...

11 minutes...

After like 20 minutes I've finally gotten my scan results back:</p>
        <p>On the UDP side of things, ports 68 (DHCP), 123 (NTP), 161 and 162 (SNMP) are open. We have a wealth of information about the SNMPv1 server likely due to an Nmap script used during the scan.

For some protocols, even port numbers are used to indicate client-side listening, and odd numbers are for server-side listening. The DHCP service is client-side listening. And if you didn't know already, DHCP is for automatically assigning IP addresses and other configuration parameters to devices on a network. The process of setting up and managing IP addresses is made easier by DHCP, because it dynamically allocates IP addresses as devices connect to the network. This is especially helpful in large networks, as manual IP address configuration would be time-consuming and more prone to errors. With DHCP, you don't have to worry about setting the IP address of a device, the protocol does it for you. DHCP handles the process by dynamically providing each device with not only an IP address, but also a subnet mask, default gateway, and other necessary network configuration settings.</p>
        <p>Connecting to https://10.129.230.96 gives me this web page:</p>
        <p>Per the "About" section of this box, SNMP is what I should be targeting next. What is SNMP anyway?

This protocol is used for sharing information among various devices on a network, regardless of their hardware or software. Architecturally, you have "managers" which are servers that collect and process information about devices on the network. Following managers are "agents", and they can be any type of device or device component that's connected to the network. They can be computers, phones, printers, network switches, etc. There's a data hierarchy within SNMP. It does in fact operate on a client-server model, but it also uses event-driven communication through SNMP traps or polling, which provide real-time updates about network events to management systems.

I noticed that SNMP exists on ports 161 AND 162. This is because manager devices using SNMP send requests to SNMP agents via 161. These requests range from commands to retrieve information to modifying device settings. 162 is used by the agents to send traps to managers. Traps alert managers to specific events or issues on the network device without the manager having to request the information. Both ports are essential for the functioning of SNMP.

Armed with that knowledge, I now seek to exploit SNMP. We know from the scan that the SNMP server could be v1, and that version happens to be relatively insecure. Communications between the manager and agent is plaintext, with SNMPv1. Apparently, v1 can only handle 32-bit counter values before rolling over. However, there's also a mention of SNMPv3 in the scan. I'm not sure how SNMPv1 and SNMPv3 are being used in relation to each other, if at all.

I turn to snmpwalk to retrieve management values. Snmpwalk does this by using SNMPGETNEXT requests to query devices on a network for information.

`snmpwalk -v2c -c public 10.129.230.96` to print a list of OIDs from the target device, where `-v2c` is for the SNMP version to use, `-c public` to specify the community string, followed by the target's IP address.

Snmpwalk returns a ton of output, some of which isn't very readable, as you can see:</p>
          <p>To make sense of this, I edit my host's snmp.conf in /etc/snmp/snmp.conf, making sure to uncomment `mibdirs' as shown:</p>
          <p>I love Vim!

`esc` then `:wq` to save and exit.

Now, I'm going to download snmp-mibs-downloader. It's designed for managing MIB (Management Information Base) files, so I'm going to need it shortly.

`apt search snmp-mibs`
`sudo apt install snmp-mibs-downloader`

I get "Package 'snmp-mibs-downloader' has no installation candidate", so I update my package list with `sudo apt update` and run the command again. The package is downloaded, and I now have the MIBS database. Back to the previous snmpwalk command, but this time I add `-m all`, so we'll get a much more useful input. Instead of just printing out random OIDs, we have now have information about them.

From snmpwalk's output, we get tons of information about packges on the target and processes running on the target. This information would probably be useful when trying to find alternative ways to exploit the machine. Better yet, a password can be found:</p>
           <p>Sadly, the login doesn't work, but not in the way you think:</p>
           <p>Entering any other combination results in "Invalid username or password", but here the panel tells me that the account has been disabled or doesn't exist. We know it existed at some point thanks to SNMP. I can probably interact with Nagios using some sort of API to get around this, so I start Burp Suite (cURL can also be used for this part, but Burp Suite is a little more intuitive).

HTB says that the API documentation for Nagios XI is weak, so I'll have to search forum posts or fuzz the API. But before that, I'm going to download FoxyProxy, which is an open-source proxy management tool. FoxyProxy switches your internet connection across one or more proxy servers using several possible methods chosen by the user. It's useful for debugging URL patterns, limiting IP address discovery by turning off WebRTC, etc. I'm going to use FoxyProxy with Burp to forward traffic to Burp, so that I can manipulate the web request before sending it to the web server.

To configure things, I go into FoxyProxy, add a new proxy, enter 127.0.0.1 in the Hostname field, and 8080 as the port number. I name the proxy "Burp" just to keep things organized. Now, I should be able to enable the proxy while Burp Suite is running. I make sure Intercept in Burp Suite is turned on, so that messages between my browser and the target web server are sent to the Proxy tab in Burp Suite. Here, we can analyze and modify messages before forwarding them.

In Burp, we can see the POST request. We have the ???

What I'm focused on is getting the token for authentication to the Nagios API. I send the request to the Repeater module of Burp, which you can see here:
</p>
           <p>I remove some uneeded information from the request:</p>
           <p>I then modify the request so that it's sent to `/nagiosxi/api/v1/authenticate` instead of /nagiosxi/login.php`. After forwarding this request to the server, a response is delivered within Burp. A nice token with which I can authenticate. :)

To start, I disable FoxyProxy, navigate back to the Nagios login panel, and modify the URL as follows: `https://10.129.230.96/nagiosxi/?token=69bf55e2b7a881f69ffa69ff63657a7c0a2b745d`...and I'm in! I've authenticated as the svc user despite the login panel telling me that the user was disabled/doesn't exist.

Snooping around, I found a page that monitors services and status information. At the bottom right of the web page is a service version number for Nagios XI, which is 5.11.0. A quick search for exploits relating to this version gives me CVE-2023-40931, an SQL injection exploit as mentioned by HTB. Very exciting!

So it reaches from 5.11.0 up to and including 5.11.1 according to NIST, and it allows authenticated attackers (such as myself ;)) to execute arbitrary SQL commands via the ID parameter in the POST request to `/nagiosxi/admin/banner_message-ajaxhelper.php`. Now, I'm going to take advantage of this.

First, I'm going to exploit this flaw manually.

I hop back into Burp and modify the request as follows:</p>
           <p></p>
        <script>
         window.addEventListener('DOMContentLoaded', (event) => {
         // Select all text in the document
         const bodyText = document.body.innerHTML;

         // Regular expression to find words surrounded by backticks
         const updatedText = bodyText.replace(/`(.*?)`/g, (match, p1) => {
         return `<span class="red-text">${p1}</span>`;
      });
      // Set the updated HTML back to the body
      document.body.innerHTML = updatedText;
    });
  </script>
    </div>
</body>
</html>
